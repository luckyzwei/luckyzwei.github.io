<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaomanbaba.top</id>
    <title>开发日记</title>
    <updated>2022-06-29T11:27:01.061Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaomanbaba.top"/>
    <link rel="self" href="https://xiaomanbaba.top/atom.xml"/>
    <subtitle>思绪随风飘，散落在这里</subtitle>
    <logo>https://xiaomanbaba.top/images/avatar.png</logo>
    <icon>https://xiaomanbaba.top/favicon.ico</icon>
    <rights>All rights reserved 2022, 开发日记</rights>
    <entry>
        <title type="html"><![CDATA[手机游戏商店截图之终极指南]]></title>
        <id>https://xiaomanbaba.top/post/shou-ji-you-xi-shang-dian-jie-tu-zhi-zhong-ji-zhi-nan/</id>
        <link href="https://xiaomanbaba.top/post/shou-ji-you-xi-shang-dian-jie-tu-zhi-zhong-ji-zhi-nan/">
        </link>
        <updated>2022-06-28T12:34:46.000Z</updated>
        <content type="html"><![CDATA[<p>你是否知道应用商店截图可以帮助你的手机游戏提高转化率？</p>
<p>你没听错--这个ASO元素足够强大到让你颤抖。</p>
<p>话虽然如此，你需要正确的优化您的应用商店图像。</p>
<p>在这份详尽的指南中了解所有关于如何设计完美的手机游戏应用商店截图的所有信息!</p>
<p><strong>为什么在ASO中应用商店截图是如此重要？</strong><br>
那我们先来看看ASO是什么，ASO指应用商店优化，指代的是增加自然应用转化并在应用商店中排名更高的过程。他包括了优化各种元素，比如引用程序的名字，icon，应用关键词，应用描述和视觉图片。</p>
<p>在应用详细页面视觉图片指的是屏幕截图和应用宣传视频，这两者是由发布者上传的。通常，在传达信息和影响人们的决定方面，视觉效果比文字更有效果。对于手机游戏来说更为重要--向用户展示玩游戏的最佳方式是通过视觉效果。</p>
<p>这就是应用商店的截图和宣传视频对ASO非常重要的原因。</p>
<p>根据Storemaven的报告，结果优化的苹果应用商店图库可以将转化率提高多大40%。</p>
<p>屏幕截图对于那些随意浏览的用户来说尤其重要，即那些在做出最终决定之前会首先浏览你的应用商店上的内容的访问者。</p>
<p>即使您是通过打广告买量的方式，也请记住，点击你的广告进来的人最终也会访问你的应用商店页面。因此，吸引人的屏幕截图不仅对自然转化很重要，对付费用户获取活动也很重要(因为付费玩家对品质要求会更高一些)。</p>
<p><strong>设计提升下载量的应用商店屏幕截图的10个技巧</strong><br>
我整理了最全面的手机游戏应用商店截图设计实用指南。通过遵循这些提示，您可以制作具有超级高水平的屏幕截图。<br>
<img src="https://xiaomanbaba.top/post-images/1656468423097.jpg" alt="" loading="lazy"><br>
<img src="https://xiaomanbaba.top/post-images/1656468632315.jpg" alt="" loading="lazy"></p>
<ol>
<li>
<p><strong>查看竞争对手的屏幕截图</strong><br>
在你开始设计之前，你需要做一些研究。首先，去找一下你的竞争对手的的产品。你只用去Google Play 和 Apple Store搜索您所在类型的热门游戏。还可以使用七麦或者点点数据这种平台来查看。<br>
下一步，看看竞争对手的截图，并问问自己以下问题：</p>
<ul>
<li>屏幕截图讲述了一个什么样的故事？</li>
<li>屏幕截图如何代表这些游戏？</li>
<li>有哪些主题？</li>
<li>屏幕截图在视觉上是否吸引人且引人注目？为什么？</li>
<li>使用什么样的艺术风格和颜色？</li>
<li>有文字说明吗？如果有，他们在传达什么信息</li>
<li>截图会让你下载这个游戏吗？</li>
</ul>
<p>通过为竞争对手的屏幕截图回答这些问题，你会有一个初步的了解他们有效的原因。<br>
现在你知道你要面对什么了--这就是起点。接下来，你需要弄清楚如何比竞争对手更好，并在商店的数千款手游中脱颖而出。</p>
</li>
<li>
<p>选择正确的朝向<br>
横向和纵向截图方向之间的选择看似简单，但是不要轻视了，他比你想象的更重要。</p>
<p>纵向屏幕截图的主要好处是能够同时展示多个功能，因为用户无需滚动即可看到多个屏幕截图。另一方面，横向屏幕截图将重点放在一个主要信息上。</p>
</li>
</ol>
<p>大多数的手机应用（根据Storemaven的数据，有95%）倾向于使用纵向图像。主要原因之一是应用程序通常不支持横向使用。此外，纵向运行应用程序一次展示多个功能。</p>
<p>但是说到手机游戏，情况就不太一样了。根据Storemaven的数据，63%的手机游戏使用横向的屏幕截图。因为许多手机游戏都支持横向玩耍。<br>
<img src="https://xiaomanbaba.top/post-images/1656474539268.jpg" alt="" loading="lazy"><br>
<strong>横向方向</strong><br>
如果你的手机游戏有横向的用户界面，并且有很强的品牌识别度（不必依赖多种信息），我们建议使用横向方向。此外，如果你的目标受众是习惯于横版游戏的的硬核玩家，请使用这种方向。<br>
<img src="https://xiaomanbaba.top/post-images/1656474723862.png" alt="" loading="lazy"></p>
<p><strong>纵向方向</strong><br>
如果您的手机游戏很复杂，需要更多解释并且具有垂直UI，请使用纵向。此外，对于三消或赌场等竞争类别的游戏，垂直方向更可取，因为这些游戏需要呈现几个独特的功能来说服用户下载它。此外，如果您的目标受众是休闲玩家，纵向似乎效果更好。<br>
即便如此，游戏通常会采用混合方法并展示横向和纵向屏幕截图。<br>
确定适合您的游戏的最佳办法是对不同的方法进行A/B测试。<br>
3. <strong>选择适合手机游戏的截图风格</strong><br>
如果你在应用商店中浏览应用程序和游戏，你会发现有许多不同的截图风格。<br>
例如，应用程序的截图通常展示它如何解决一个特定的问题。此外，许多应用程序使用生活方式的截图，即在现实生活环境中展示应用程序，并向用户展示如何使用它。然而，这种风格对于手机游戏来说并不是最好的选择，因为他们主要用于娱乐。<br>
这里列举了几个适合游戏的最流行的截图风格。<br>
<img src="https://xiaomanbaba.top/post-images/1656475223681.png" alt="" loading="lazy"><br>
<strong>展示功能的截图</strong><br>
手机游戏的截图最常见的是描述一个游戏的首要功能和好处。例如，这些图片可以描述建造城市，与敌人作战，与朋友玩耍和参加现场活动的能力。通常情况下，每张截图只有一个功能,并配置有说明<br>
当然，这里的目标是将你的游戏与该类型的其他游戏区分开来。换句话说，突出独特的功能或好处，使你超越竞争对手。<br>
<img src="https://xiaomanbaba.top/post-images/1656485011269.png" alt="" loading="lazy"><br>
<strong>以游戏性为重点截图</strong><br>
如果你在游戏过程中对游戏就行截图，这就是游戏性截图。如果做得好，这种类型的截图风格可以让人对比的游戏产生兴趣。这种风格的另一个好处是，玩家可以看到游戏的样子，知道一旦安装后会有什么期待。<br>
确保在正确的时间，即在最激动人心的游戏时刻捕捉屏幕截图。例如，最后的BOSS战或肾上腺素分泌旺盛的锦标赛。<br>
<img src="https://xiaomanbaba.top/post-images/1656485198182.png" alt="" loading="lazy"><br>
<strong>以游戏角色为特征的截图</strong><br>
在所有的游戏元素中，玩家与游戏人物的联系最多。此外，游戏人物通常是手机游戏中最容易识别的部分。<br>
正因为如此，许多发行商采用以角色为重点的截图。<br>
如果你的游戏有一个推动故事发展的主角，或者游戏的吉祥物是人们下载你的游戏的主要原因，你应该采用这种截图风格。<br>
此外，对于具有良好品牌知名度的流行IP来说，这是一个特别明智的选择。例如，像Moon Active的《硬币大师》，Rovio的《愤怒的小鸟》或Outfit7的《我的会说话的汤姆猫》，这些游戏都有流行的，广为人知的游戏角色。<br>
<img src="https://xiaomanbaba.top/post-images/1656485572944.jpg" alt="" loading="lazy"><br>
<strong>艺术性截图</strong><br>
如果你想做自己的事情，用独特的东西让用户惊叹，就去为你的截图创建一个定制的艺术设计。你可以从游戏中获取视觉效果，并将其与其他设计元素想结合，创造出一个与众不同的截图。<br>
例如，飞溅屏是一种非常流行的艺术截图风格。<br>
然而，不要迷失在你的艺术创作中。确保它仍然清楚游戏的内容，并强调其USP。</p>
<p>** 混合截图**<br>
如果你不能决定采用哪种风格？那么，为什么不把所有的东西都做一下，把这些不同的方法结合起来。<br>
4. <strong>尝试全景图库</strong><br>
设计应用商店截图的另一种很酷的方式是创建一个全景画廊。这种风格包括跨越一个以上的屏幕截图的设计。其目的是让截图看起来像一个连续的图像。<br>
全景屏幕截图看起来非常酷，他们很抢眼，并鼓励用户继续滚动浏览图片。这就是使他们如此受欢迎的原因。<br>
尽管这种类型的设计咋看之下可能很复杂，但实际上并不难做。关键是要考虑图片之间的间隙，使其无缝链接。<br>
<img src="https://xiaomanbaba.top/post-images/1656486645957.png" alt="" loading="lazy"><br>
5. <strong>牢记基本设计原则</strong><br>
事情是这样的。<br>
应用商店的截图应该遵循与其他图形或图像相同的基本图形设计原则。例如，构图，对比，重复，强调，比例等等。<br>
这意味着图片的构图需要平衡，所有的元素都需要对齐，并保持和谐。此外，你想突出的元素应该被强调，并有额外的视觉重量，这也被称为平面设计中的层次。使用重复（持续使用相同的颜色，字体或形状），将所有的截图联系在一起，使他们看起来有凝聚力。<br>
不要忘记使设计与你的品牌形象一直。如果你是一个知名的出版商，你的屏幕截图应该能让人一眼认出。然而，如果你刚刚起步，截图设计是开始建立一个独特品牌形象的好办法。<br>
如果你出版了多个游戏，特别是如果他们属于同一类别，那么为所有的游戏设计一个类似的屏幕截图是个好主意。例如，Playrix的Homeescapes, Gardenscapes和Fishdom的截图有完全相同的设计。甚至截图和战士的功能也非常相似。只有颜色方案在不同的游戏中有些不同。<br>
<img src="https://xiaomanbaba.top/post-images/1656487221718.png" alt="" loading="lazy"><br>
6. <strong>选择正确的调色板</strong><br>
色彩在设计中的重要性来自于色彩对人类思维的重要性。颜色有能力传达思想，让我们感受到某种情绪，或者激发我们的兴趣。<br>
正因为如此， 你选择的调色板是应用商店截图中最关键的部分之一。<br>
如果你不知道该用哪种颜色，可以从你的游戏和整体品牌的配色开始。很多时候，最好的选择是坚持使用这些颜色。然而，你可以尝试添加额外的色调，在截图设计中创造强调或对比。<br>
<img src="https://xiaomanbaba.top/post-images/1656487711195.png" alt="" loading="lazy"><br>
假设你的游戏调色板中的主要颜色是中深棕色，深青色，黄橙色和橙红色。你可以用他们作为截图的基础色，并添加一个较深的色块来形成对比，使截图更加醒目。例如，像午夜蓝，深紫色，猎人绿或浓黑这样的色调与这些基础色搭配起来效果很好，正如你在上图中看到的那样。<br>
<img src="https://xiaomanbaba.top/post-images/1656488064168.png" alt="" loading="lazy"><br>
7. <strong>为屏幕截图添加标题以突出显示功能</strong><br>
大多数应用商店的截图都有文字，也就是突出游戏的最佳功能或好处的标题。此外它们往往直接对用户说话。<br>
例如，如果你有一个三消游戏的截图，标题可能是“Solve match-3 puzzles”或 “Match!”或者简单的 “Play”。<br>
确保强调你的游戏的USP，也就是说，让人们知道哪些功能使它与众不同，更令人兴奋，或者仅仅是比其他游戏更好。<br>
例如，Toon Blast的截图的标题是“爆破方块”，“有趣的谜题”， “享受助推器”， “收集新物品”，“获得奖励”和“5000多级”。<br>
此外，确保标题易于辨认，短小精悍，直奔主题，并传递所需信息。不要忘记，标题的字体应遵循你的品牌形象。<br>
<img src="https://xiaomanbaba.top/post-images/1656488668726.jpg" alt="" loading="lazy"><br>
8. <strong>用额外的设计元素吸引注意力</strong><br>
应用程序商店的图片往往受益于额外的视觉元素，丰富了设计。例如，你可以为游戏截图创建一个框架，添加一个背景，或其他图形。它们的目的是传递额外的信息，强调标题，或只是补充整体设计。</p>
<p>你可以在上面的图片中看到一个使用附加设计元素的很酷的例子。这个截图是为Pokémon UNITE拍摄的。它是以艺术风格完成的--没有实际的游戏截图，而是以数字绘画的方式描绘了一个以主要人物为主角的行动场景。</p>
<p>在左边，你会注意到有几个元素被添加到这个设计中，使其更有活力，最重要的是奖杯。这个金色的奖杯上有一个Google Play的标志，因为《口袋妖怪联盟》被评为Google Play的2021年最佳游戏奖。这是一个很好的例子，说明如何通过添加额外的视觉元素，用屏幕截图传递更多信息。</p>
<p>你可以做的另一件事是添加你的标志，使你的品牌更容易被识别。然而，请确保你不要太过分，使设计过于繁忙。一个简单而精简的设计通常是最好的。<br>
<img src="https://xiaomanbaba.top/post-images/1656488938741.png" alt="" loading="lazy"><br>
9.  <strong>如果你在苦苦挣扎，购买App Store截图模板</strong><br>
如果你不是那么热衷于从头开始设计自己的图片，你可能会从购买一个应用商店截图模板中受益。</p>
<p>这使整个过程变得非常容易--你唯一需要做的就是定制模板。</p>
<p>在不同的商店如Envato Elements和Creative Market中搜索应用商店屏幕截图模板。最常见的是，你购买的应用程序商店截图模板是用Figma构建的。这意味着图形元素、颜色和尺寸都可以调整。</p>
<p>使用应用程序商店屏幕截图模板的缺点是，你的屏幕截图不会是100%独特的，因为其他出版商可能也使用相同的模板。此外，你可能无法找到适合你特定需求的模板。<br>
10. <strong>试试App Store截图生成器</strong><br>
现在，如果你不想从头设计自己的图片或购买模板，还剩下一个选择--尝试应用商店截图生成器。</p>
<p>有了这种类型的工具，你可以在几分钟内创建和导出屏幕截图。顶级应用商店屏幕截图生成器往往提供基于流行应用的模板和布局，这简化了设计过程。此外，这些工具通常允许你以所有需要的尺寸导出你的图像。一些工具甚至提供先进的功能，如本地化和全景背景。</p>
<p><strong>额外提示</strong><br>
需要更多关于如何设计完美截图和擅长应用商店优化的建议？这里有三个额外的提示。<br>
<img src="https://xiaomanbaba.top/post-images/1656489578803.jpg" alt="" loading="lazy"></p>
<ol>
<li>
<p><strong>截图本地化</strong><br>
发行商希望能够接触到尽可能多的玩家。出于这个原因，大多数移动游戏在全球多个不同国家发布。</p>
<p>为了使你的手机游戏能够吸引不同的受众，你需要将你的截图和其他ASO元素本地化。</p>
<p>然而，本地化不仅仅是翻译--这只是最基本的。</p>
<p>真正的本地化是指为另一种文化调整你的所有的内容。即使是你可能认为是通用的设计部分，例如颜色，也可能在不同的文化中激起不同的反应。</p>
</li>
<li>
<p><strong>在Google Play和苹果的应用商店使用不同的截图</strong><br>
你可能会想，你可以简单的制作同一套屏幕截图，并在google play 和 苹果商店同时发布，一石二鸟对吧。<br>
从技术上讲，你可以在所有商店使用相同的截图，但这并不意味着你应该这样做。</p>
</li>
</ol>
<p>事情是这样的。<br>
Google Play 和 苹果商店是两个非常不同的平台，你应该单独对待他们。例如，商店的设计，图像分辨率和功能都非常不同。更不用说每个商店都有不同的受众和不同的偏好。</p>
<p>正因为如此，对谷歌有效的ASO策略可能对苹果无效，反之亦然。</p>
<p>为了确保你在所有应用商店都名列前茅，要避免使用相同的截图，而是要为每个商店调整你的设计。<br>
<img src="https://xiaomanbaba.top/post-images/1656490736279.png" alt="" loading="lazy"><br>
3. <strong>选择正确的屏幕截图顺序</strong><br>
这可能看起来很明显，但值得一提。你选择的截图顺序对用户如何接受你的游戏起着很大的作用。选择哪张截图放在前面这样简单的事情，可以使用户在安装你的游戏和失去兴趣之间产生差异。</p>
<p>就像其他事情一样，你应该试着给人留下良好的第一印象。请记住，大多数用户不会滚动浏览所有图片。正因为如此，那些描绘了你的目标受众会觉得最激动人心的功能的截图应该首先出现。</p>
<p>在这种情况下，把最好的留到最后并不是一个好的选择。</p>
<p><strong>如何对应用商店进行A/B Test?</strong><br>
你可能在想，你怎么知道你的截图设计是否好？找到这个问题答案的唯一科学方法就是测试屏幕截图。A/B测试将帮助你优化图片以达到最高的转换率。</p>
<p>下面是如何通过四个简单的步骤对应用商店的截图进行A/B测试。</p>
<ol>
<li>制定一个假设<br>
每个A/BTest的第一步是建立一个假设--它是至关重要的，为测试提供方向。如果你胡乱地做这一部分，没有想出一个足够强大的假设，你就不会得到好的结果。<br>
记住，假设需要明确和大胆。你需要描述变化，以及你认为结果会是什么，为什么。</li>
</ol>
<p>下面是一些你可以测试的假设的例子。<br>
人们对以角色为重点的截图的反应会比对艺术截图的反应好。<br>
纵向截图将比横向截图转换更多的用户。<br>
展示现场活动和锦标赛的截图将比普通游戏截图的转化率更高。<br>
白色的标题文本将比黑色的标题文本转换更多的用户。<br>
在标题中强调社交功能，排行榜和与朋友一起玩的能力，将增加转化率。<br>
2. 设计一个变体<br>
在你开始测试之前，你需要一个变体A和一个变体B。前者是原始图像，后者是该图像的变体，包含你根据你的假设所修改的元素。<br>
这样，你就可以在测试完成后对两者进行比较<br>
3. 导入流量<br>
为了使测试有效，你需要大量的数据。<br>
在测试应用商店截图这一步骤总，你需要为你的游戏的应用商店页面输入流量。<br>
4. 评估结果<br>
最后，是时候分析你的A/B测试结果了，看看哪些截图能带来更高的转化率。<br>
提示--为了简化测试过程，尝试使用这些顶级的ASO工具。</p>
<p>手机游戏的应用商店截图示例<br>
现在你已经了解了为你的移动游戏设计，优化和测试应用商店截图的来龙去脉，让我们看看顶级玩家是如何做得。</p>
<p>在这些例子中，你会看到所有上述的技巧都在发挥作用。用他们来获得灵感，看看什么对顶级移动游戏有用。<br>
<img src="https://xiaomanbaba.top/post-images/1656492064892.png" alt="" loading="lazy"><br>
Homescape<br>
如前所述，Playrix想出了一个可识别的截图设计，该设计用于其投资组合中的所有游戏，并就行了微小的调整。下面是一个例子，说明Homescapes的情况。</p>
<p>Homescape的Google Play商店页面上的截图是水平的，每张截图都展示了一个游戏功能。这些图片不是实际的游戏截图，而是对他的艺术的诠释。</p>
<p>每张截图上方都有一个标题，强调玩家在Homeescapes中可以做的有趣的事情。标题的对角线构图机器在洋红色背景下的白色字体使其脱颖而出，吸引用户的注意力。<br>
<img src="https://xiaomanbaba.top/post-images/1656492624387.png" alt="" loading="lazy"><br>
正如你在上图中所看到的，Homescape截图的调色板以洋红色为主，这是这个设计中最突出的颜色。其他颜色包括深浅不一的蓝色，绿色，橙褐色和灰色。</p>
<figure data-type="image" tabindex="1"><img src="https://xiaomanbaba.top/post-images/1656492726214.png" alt="" loading="lazy"></figure>
<p><strong>EverMerge</strong><br>
EverMerge在Google Play上的截图很好地表现了它的游戏性，在设计上有一些艺术自由。</p>
<p>正如你所期望的那样，每张截图都几种在一个游戏功能上，标题直接对用户说话，例如，“发现一个神奇的世界”。</p>
<p>第一张截图与其他的稍有不同，因为他有一个前后类型的布局，上面有一条对角线，这很受欢迎。<br>
<img src="https://xiaomanbaba.top/post-images/1656496194942.png" alt="" loading="lazy"></p>
<p>尽管所有屏幕截图都非常丰富多彩，但字幕通过使用紫色/橙色对比而脱颖而出。</p>
<p>Evermerge截图的调色板充满了不同深浅的绿色，紫色，蓝色和棕色。</p>
<figure data-type="image" tabindex="2"><img src="https://xiaomanbaba.top/post-images/1656496310155.png" alt="" loading="lazy"></figure>
<p>Brawl Star的Google Play截图充满活力，设计精良，需要关注。它们不仅包括捕捉到的游戏画面，还包括游戏人物、多彩的背景和标题。</p>
<p>所有这些放在一起，讲述了一个故事，并邀请玩家下载《争吵之星》。<br>
<img src="https://xiaomanbaba.top/post-images/1656500931435.png" alt="" loading="lazy"><br>
争吵之星》截图的色彩故事非常独特，这也是它如此引人注目的原因--它在所有其他游戏中脱颖而出。</p>
<p>主导颜色是热辣辣的红色，加上冷色调的浅皇家蓝，形成了完美的对比。</p>
<p><strong>应用商店截图指南</strong><br>
这一点不言而喻，但你必须确保你的屏幕截图符合应用商店的准则，无论是苹果商店、Google Play，还是其他商店。请记住，每个商店在尺寸和内容方面有不同的指导方针和要求。</p>
<p>以下是最重要的几条。</p>
<p><strong>苹果应用商店屏幕截图指南</strong><br>
截图需要直接从应用程序/游戏中拍摄。<br>
禁止使用别人玩你的游戏的图片。<br>
你必须提供所有不同设备类型的截图（查看以下每种设备的尺寸）。<br>
你最多可以上传10张屏幕截图。<br>
屏幕截图可以是横向或纵向的。<br>
<strong>谷歌游戏屏幕截图指南</strong><br>
你必须上传的最小屏幕截图数量为2张，最大为8张。<br>
屏幕截图可以是横向或纵向的。<br>
你必须遵循Google Play的屏幕截图尺寸。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[es创建索引]]></title>
        <id>https://xiaomanbaba.top/post/es-chuang-jian-suo-yin/</id>
        <link href="https://xiaomanbaba.top/post/es-chuang-jian-suo-yin/">
        </link>
        <updated>2020-04-02T02:36:04.000Z</updated>
        <content type="html"><![CDATA[<p>前面使用filebeats收集日志</p>
<p>然后发送到logstash来清洗日志</p>
<p>最后发送到es的索引中。</p>
<p>这里我们看看如何创建索引。<br>
实例：</p>
<p>PUT users<br>
{<br>
&quot;mappings&quot;: {<br>
&quot;properties&quot;:{<br>
&quot;name&quot;:{<br>
&quot;type&quot;:&quot;text&quot;<br>
},<br>
&quot;user_name&quot;:{<br>
&quot;type&quot;: &quot;keyword&quot;<br>
},<br>
&quot;email&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
}<br>
}<br>
}<br>
}</p>
<p>上面创建了一个users的索引。但是我们这里不会单独的创建一个索引，因为单个索引数据量太大会导致检索查询的性能问题，所以我们按照时间序列来生成索引，所以我们创建索引模板。<br>
PUT _template/template_1<br>
{</p>
<p>&quot;index_patterns&quot;: [&quot;ubi*&quot;],<br>
&quot;settings&quot;:{<br>
&quot;number_of_shards&quot;:1<br>
},<br>
&quot;mappings&quot;:{</p>
<pre><code>  &quot;properties&quot;:{
    
    &quot;host_name&quot;:{
      &quot;type&quot;:&quot;keyword&quot;
    },
    &quot;created_at&quot;:{
      &quot;type&quot;:&quot;date&quot;,
      &quot;format&quot;:&quot;&quot;
    }
  }
</code></pre>
<p>}<br>
}<br>
这样生成了一个template_1的索引模板，有两个字段 host_name created_at。</p>
<p>到我们这个业务统计来说，我们生成几个索引模板，分别为:<br>
reg-*<br>
login-*<br>
output-*<br>
cardlevelup-*<br>
newrecharge-*<br>
PUT _template/reg-*<br>
{<br>
&quot;index_patterns&quot;: [&quot;reg-*&quot;],<br>
&quot;settings&quot;:{<br>
&quot;number_of_shards&quot;:5<br>
},<br>
&quot;mappings&quot;:{<br>
&quot;properties&quot;:{<br>
&quot;logtype&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;uid&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;os&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;channel&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;version&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;udid&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;source&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;timestamp&quot;:{<br>
&quot;type&quot;:&quot;date&quot;,<br>
&quot;format&quot;:&quot;epoch_second&quot;<br>
},<br>
&quot;networkType&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;ip&quot;:{<br>
&quot;type&quot;:&quot;ip&quot;<br>
},<br>
&quot;area&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
}<br>
}<br>
}<br>
}</p>
<p>登录的索引模板<br>
PUT _template/login-*<br>
{<br>
&quot;index_patterns&quot;: [&quot;login-*&quot;],<br>
&quot;settings&quot;:{<br>
&quot;number_of_shards&quot;:5<br>
},<br>
&quot;mappings&quot;:{<br>
&quot;properties&quot;:{<br>
&quot;logtype&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;uid&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;os&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;channel&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;version&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;udid&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;source&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;timestamp&quot;:{<br>
&quot;type&quot;:&quot;date&quot;,<br>
&quot;format&quot;:&quot;epoch_second&quot;<br>
},<br>
&quot;networkType&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;ip&quot;:{<br>
&quot;type&quot;:&quot;ip&quot;<br>
},<br>
&quot;area&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;regtime&quot;:{<br>
&quot;type&quot;:&quot;date&quot;,<br>
&quot;format&quot;:&quot;epoch_second&quot;<br>
},<br>
&quot;lv&quot;:{<br>
&quot;type&quot;:&quot;integer&quot;<br>
},<br>
&quot;rest_coin&quot;:{<br>
&quot;type&quot;:&quot;integer&quot;<br>
}<br>
}<br>
}<br>
}</p>
<p>消耗的索引模板<br>
PUT _template/cost-*<br>
{<br>
&quot;index_patterns&quot;: [&quot;cost-*&quot;],<br>
&quot;settings&quot;:{<br>
&quot;number_of_shards&quot;:5<br>
},<br>
&quot;mappings&quot;:{<br>
&quot;properties&quot;:{<br>
&quot;logtype&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;uid&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;os&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;channel&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;version&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;udid&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;source&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;timestamp&quot;:{<br>
&quot;type&quot;:&quot;date&quot;,<br>
&quot;format&quot;:&quot;epoch_second&quot;<br>
},<br>
&quot;networkType&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;ip&quot;:{<br>
&quot;type&quot;:&quot;ip&quot;<br>
},<br>
&quot;area&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;cost&quot;:{<br>
&quot;type&quot;:&quot;integer&quot;<br>
},<br>
&quot;itemid&quot;:{<br>
&quot;type&quot;:&quot;integer&quot;<br>
}<br>
}<br>
}<br>
}</p>
<p>新手引导进度索引模板<br>
PUT _template/guide-*<br>
{<br>
&quot;index_patterns&quot;: [&quot;guide-*&quot;],<br>
&quot;settings&quot;:{<br>
&quot;number_of_shards&quot;:5<br>
},<br>
&quot;mappings&quot;:{<br>
&quot;properties&quot;:{<br>
&quot;logtype&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;uid&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;os&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;channel&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;version&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;udid&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;source&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;timestamp&quot;:{<br>
&quot;type&quot;:&quot;date&quot;,<br>
&quot;format&quot;:&quot;epoch_second&quot;<br>
},<br>
&quot;networkType&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;ip&quot;:{<br>
&quot;type&quot;:&quot;ip&quot;<br>
},<br>
&quot;area&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;process&quot;:{<br>
&quot;type&quot;:&quot;integer&quot;<br>
}<br>
}<br>
}<br>
}</p>
<p>卡牌升级索引模板<br>
PUT _template/cardlevelup-*<br>
{<br>
&quot;index_patterns&quot;: [&quot;cardlevelup-*&quot;],<br>
&quot;settings&quot;:{<br>
&quot;number_of_shards&quot;:5<br>
},<br>
&quot;mappings&quot;:{<br>
&quot;properties&quot;:{<br>
&quot;logtype&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;uid&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;os&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;channel&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;version&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;udid&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;source&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;timestamp&quot;:{<br>
&quot;type&quot;:&quot;date&quot;,<br>
&quot;format&quot;:&quot;epoch_second&quot;<br>
},<br>
&quot;networkType&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;ip&quot;:{<br>
&quot;type&quot;:&quot;ip&quot;<br>
},<br>
&quot;area&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;cardid&quot;:{<br>
&quot;type&quot;:&quot;integer&quot;<br>
},<br>
&quot;lvto&quot;:{<br>
&quot;type&quot;:&quot;integer&quot;<br>
}<br>
}<br>
}<br>
}</p>
<p>产出的索引模板<br>
PUT _template/output-*<br>
{<br>
&quot;index_patterns&quot;: [&quot;output-*&quot;],<br>
&quot;settings&quot;:{<br>
&quot;number_of_shards&quot;:5<br>
},<br>
&quot;mappings&quot;:{<br>
&quot;properties&quot;:{<br>
&quot;logtype&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;uid&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;os&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;channel&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;version&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;udid&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;source&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;timestamp&quot;:{<br>
&quot;type&quot;:&quot;date&quot;,<br>
&quot;format&quot;:&quot;epoch_second&quot;<br>
},<br>
&quot;networkType&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;ip&quot;:{<br>
&quot;type&quot;:&quot;ip&quot;<br>
},<br>
&quot;area&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;itemid&quot;:{<br>
&quot;type&quot;:&quot;integer&quot;<br>
},<br>
&quot;number&quot;:{<br>
&quot;type&quot;:&quot;integer&quot;<br>
}<br>
}<br>
}<br>
}</p>
<p>充值的索引模板<br>
PUT _template/charge-*<br>
{<br>
&quot;index_patterns&quot;: [&quot;charge-*&quot;],<br>
&quot;settings&quot;:{<br>
&quot;number_of_shards&quot;:5<br>
},<br>
&quot;mappings&quot;:{<br>
&quot;properties&quot;:{<br>
&quot;logtype&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;uid&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;os&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;channel&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;version&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;udid&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;source&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;timestamp&quot;:{<br>
&quot;type&quot;:&quot;date&quot;,<br>
&quot;format&quot;:&quot;epoch_second&quot;<br>
},<br>
&quot;networkType&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;ip&quot;:{<br>
&quot;type&quot;:&quot;ip&quot;<br>
},<br>
&quot;area&quot;:{<br>
&quot;type&quot;:&quot;keyword&quot;<br>
},<br>
&quot;money&quot;:{<br>
&quot;type&quot;:&quot;integer&quot;<br>
}<br>
}<br>
}<br>
}</p>
<p>注意，这里的date支持三种模式，一种是字符串的日期表示，一种是从1970年到现在的毫秒数，一种是从1970年到现在的秒数，之前我没设置format的这个字段，于是默认就是毫秒，导致结果不太准确。 这里设置了format:epoch_second就是秒的形式来设置的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[logstash根据message中的不同类型的日志输出到不同的es中]]></title>
        <id>https://xiaomanbaba.top/post/logstash-gen-ju-message-zhong-de-bu-tong-lei-xing-de-ri-zhi-shu-chu-dao-bu-tong-de-es-zhong/</id>
        <link href="https://xiaomanbaba.top/post/logstash-gen-ju-message-zhong-de-bu-tong-lei-xing-de-ri-zhi-shu-chu-dao-bu-tong-de-es-zhong/">
        </link>
        <updated>2020-04-01T03:31:24.000Z</updated>
        <content type="html"><![CDATA[<p>当我们从beats输入数据后，然后通过grok把需要的字段抽取出来，然后输出到es中，下面是简单的一个配置文件<br>
input {<br>
beats {<br>
port =&gt; &quot;5044&quot;<br>
}<br>
}</p>
<p>filter {<br>
grok {<br>
match =&gt; { &quot;message&quot; =&gt; &quot;uid:%{WORD:uid}[T ]channel:%{WORD:channel}[T ]os:%{WORD:os}[T ]money:%{WORD:money}[T ]timestamp:%{WORD:timestamp}&quot;}<br>
}</p>
<p>}</p>
<p>output {</p>
<pre><code>elasticsearch {
	hosts =&gt; [&quot;http://192.168.1.29:9200&quot;]
	index =&gt; &quot;recharge-%{+YYYY.MM.dd}&quot;
}

stdout { codec =&gt; rubydebug }
</code></pre>
<p>}</p>
<h1 id="geoip">geoip {</h1>
<h1 id="source-clientip">source =&gt; &quot;clientip&quot;</h1>
<h1 id="">}</h1>
<p>#https://www.elastic.co/guide/en/logstash/current/advanced-pipeline.html</p>
<p>目前有一个需求，现在我们的业务日志是存放在一个日志文件中，然后每行日志里面有一个logtype的字段指明日志的类型。这就需要我们filter的时候匹配到各种日志格式，然后根据logtype来分发到不同的index中。</p>
<p>看下面的例子：</p>
<p>我们的数据源是这个：<br>
[2020/04/01 19:49:00 CST] [DEFAULT] [DEBG] (main.addUser:172) logtype:reg uid:10000 os:web channel:meizu version:1 udid:g8tnwtu0k7qdcc80 source:8 timestamp:1585741740 networkType:5g ip:205.48.79.22 area:10</p>
<p>grok匹配的模式是这个：<br>
logtype:%{WORD:logtype}[T ]uid:%{WORD:uid}[T ]os:%{WORD:os}[T ]channel:%{WORD:channel}[T ]version:%{WORD:version}[T ]udid:%{WORD:udid}[T ]source:%{WORD:source}[T ]timestamp:%{WORD:timestamp}[T ]networkType:%{WORD:networkType}[T ]ip:%{IP:ip}[T ]area:%{WORD:area}</p>
<p>然后在output节点可以根据某些字段来处理不同的逻辑，最后我们的配置文件为：<br>
input {<br>
beats {<br>
port =&gt; &quot;5044&quot;<br>
}<br>
}</p>
<p>filter {<br>
grok {<br>
match =&gt; { &quot;message&quot; =&gt; [<br>
#充值<br>
&quot;logtype:%{WORD:logtype}[T ]uid:%{WORD:uid}[T ]os:%{WORD:os}[T ]channel:%{WORD:channel}[T ]version:%{WORD:version}[T ]udid:%{WORD:udid}[T ]source:%{WORD:source}[T ]timestamp:%{WORD:timestamp}[T ]networkType:%{WORD:networkType}[T ]ip:%{IP:ip}[T ]area:%{WORD:area}[T ]money:%{WORD:money}&quot;,</p>
<pre><code>		#道具产出
		&quot;logtype:%{WORD:logtype}[T ]uid:%{WORD:uid}[T ]os:%{WORD:os}[T ]channel:%{WORD:channel}[T ]version:%{WORD:version}[T ]udid:%{WORD:udid}[T ]source:%{WORD:source}[T ]timestamp:%{WORD:timestamp}[T ]networkType:%{WORD:networkType}[T ]ip:%{IP:ip}[T ]area:%{WORD:area}[T ]itemid:%{WORD:cardid}[T ]number:%{WORD:lvto}&quot;,

		#卡牌升级
		&quot;logtype:%{WORD:logtype}[T ]uid:%{WORD:uid}[T ]os:%{WORD:os}[T ]channel:%{WORD:channel}[T ]version:%{WORD:version}[T ]udid:%{WORD:udid}[T ]source:%{WORD:source}[T ]timestamp:%{WORD:timestamp}[T ]networkType:%{WORD:networkType}[T ]ip:%{IP:ip}[T ]area:%{WORD:area}[T ]cardid:%{WORD:cardid}[T ]lvto:%{WORD:lvto}&quot;,

		#新手引导
		&quot;logtype:%{WORD:logtype}[T ]uid:%{WORD:uid}[T ]os:%{WORD:os}[T ]channel:%{WORD:channel}[T ]version:%{WORD:version}[T ]udid:%{WORD:udid}[T ]source:%{WORD:source}[T ]timestamp:%{WORD:timestamp}[T ]networkType:%{WORD:networkType}[T ]ip:%{IP:ip}[T ]area:%{WORD:area}[T ]process:%{WORD:process}&quot;,


		#金币消耗
		&quot;logtype:%{WORD:logtype}[T ]uid:%{WORD:uid}[T ]os:%{WORD:os}[T ]channel:%{WORD:channel}[T ]version:%{WORD:version}[T ]udid:%{WORD:udid}[T ]source:%{WORD:source}[T ]timestamp:%{WORD:timestamp}[T ]networkType:%{WORD:networkType}[T ]ip:%{IP:ip}[T ]area:%{WORD:area}[T ]cost:%{WORD:cost}[T ]itemid:%{WORD:itemid}&quot;,


		#登录login
		&quot;logtype:%{WORD:logtype}[T ]uid:%{WORD:uid}[T ]os:%{WORD:os}[T ]channel:%{WORD:channel}[T ]version:%{WORD:version}[T ]udid:%{WORD:udid}[T ]source:%{WORD:source}[T ]timestamp:%{WORD:timestamp}[T ]networkType:%{WORD:networkType}[T ]ip:%{IP:ip}[T ]area:%{WORD:area}[T ]regtime:%{WORD:regtime}[T ]lv:%{WORD:lv}[T ]rest_coin:%{WORD:rest_coin}&quot;,


		#注册，这个要放最后,不然前后的都可以匹配 reg
		&quot;logtype:%{WORD:logtype}[T ]uid:%{WORD:uid}[T ]os:%{WORD:os}[T ]channel:%{WORD:channel}[T ]version:%{WORD:version}[T ]udid:%{WORD:udid}[T ]source:%{WORD:source}[T ]timestamp:%{WORD:timestamp}[T ]networkType:%{WORD:networkType}[T ]ip:%{IP:ip}[T ]area:%{WORD:area}&quot;
	]
	}
}
</code></pre>
<p>}</p>
<p>output {</p>
<pre><code>if [logtype] == &quot;reg&quot;{
	elasticsearch {
		hosts =&gt; [&quot;http://192.168.1.29:9200&quot;]
		index =&gt; &quot;reg-%{+YYYY.MM.dd}&quot;
	}
}
if [logtype] == &quot;login&quot;{
	elasticsearch {
		hosts =&gt; [&quot;http://192.168.1.29:9200&quot;]
		index =&gt; &quot;login-%{+YYYY.MM.dd}&quot;
	}
}
if [logtype] == &quot;cost&quot;{
	elasticsearch {
		hosts =&gt; [&quot;http://192.168.1.29:9200&quot;]
		index =&gt; &quot;cost-%{+YYYY.MM.dd}&quot;
	}
}
if [logtype] == &quot;guide&quot;{
	elasticsearch {
		hosts =&gt; [&quot;http://192.168.1.29:9200&quot;]
		index =&gt; &quot;guide-%{+YYYY.MM.dd}&quot;
	}
}
if [logtype] == &quot;cardlevelup&quot;{
	elasticsearch {
		hosts =&gt; [&quot;http://192.168.1.29:9200&quot;]
		index =&gt; &quot;cardlevelup-%{+YYYY.MM.dd}&quot;
	}
}
if [logtype] == &quot;output&quot;{
	elasticsearch {
		hosts =&gt; [&quot;http://192.168.1.29:9200&quot;]
		index =&gt; &quot;output-%{+YYYY.MM.dd}&quot;
	}
}
if [logtype] == &quot;charge&quot;{
	elasticsearch {
		hosts =&gt; [&quot;http://192.168.1.29:9200&quot;]
		index =&gt; &quot;charge-%{+YYYY.MM.dd}&quot;
	}
}


stdout { codec =&gt; rubydebug }
</code></pre>
<p>}</p>
<h1 id="geoip-2">geoip {</h1>
<h1 id="source-clientip-2">source =&gt; &quot;clientip&quot;</h1>
<h1 id="-2">}</h1>
<p>#https://www.elastic.co/guide/en/logstash/current/advanced-pipeline.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[this 一直指向前一个对象]]></title>
        <id>https://xiaomanbaba.top/post/this-yi-zhi-zhi-xiang-qian-yi-ge-dui-xiang/</id>
        <link href="https://xiaomanbaba.top/post/this-yi-zhi-zhi-xiang-qian-yi-ge-dui-xiang/">
        </link>
        <updated>2020-03-12T07:00:54.000Z</updated>
        <content type="html"><![CDATA[<p>在使用了react-native-admob插件之后，第二次始终是指向前面的一个this对象。 调试了蛮久，发现是因为我每次调用广告的时候都会addListener，然后插件其实会存起来。<br>
首先我们应该调用<br>
removeAllListeners();</p>
<pre><code>if (global.loadingReward) {
  console.log('正在加载广告，跳过!!!');
  return;
}
this.hasRecv = false;
console.log('开始加载广告!!!');
global.loadingReward = true;
AdMobRewarded.setTestDevices([AdMobRewarded.simulatorId]);
//AdMobRewarded.setAdUnitID('ca-app-pub-9280092940596395/3561826862');
AdMobRewarded.setAdUnitID('ca-app-pub-3940256099942544/5224354917');
AdMobRewarded.removeAllListeners();
AdMobRewarded.addEventListener('rewarded', reward =&gt; {
  if (this.hasRecv){
    return;
  }
  this.hasRecv = true;
  console.log('AdMobRewarded =&gt; rewarded', reward);
  global.loadingReward = false;
  successCallback();
});
AdMobRewarded.addEventListener('adFailedToLoad', error =&gt; {
  global.loadingReward = false;
  console.log('failed:', error);
  errorCallback();
});
AdMobRewarded.addEventListener('adClosed', ()=&gt;{
  console.log('adClosed!!!');
  if(global.loadingReward == false){
    return;
  }
  global.loadingReward = false;
  errorCallback();
})
AdMobRewarded.requestAd()
  .then(() =&gt; AdMobRewarded.showAd())
  .catch(error =&gt; {
    global.loadingReward = false;
    console.log('failed:', error);
    errorCallback();
  });
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React Native Reanimated]]></title>
        <id>https://xiaomanbaba.top/post/react-native-reanimated/</id>
        <link href="https://xiaomanbaba.top/post/react-native-reanimated/">
        </link>
        <updated>2020-02-29T06:32:45.000Z</updated>
        <content type="html"><![CDATA[<p>用RN 自带的animation做的动作转盘的动画比较卡，所以看了一下React Native Reanimated的文档。<br>
官网为：https://software-mansion.github.io/react-native-reanimated/index.html</p>
<p>上面介绍说这是React Native Animated库的重新实现。<br>
有下面几个好处：</p>
<ol>
<li>Native的性能：在JS中定义动画，但是在Native线程中跑</li>
<li>精确的动画：API提供了对动画更高的精度和更详细的控制</li>
<li>(大部分)后向兼容：如果您一直使用React Native的API。您不需要做任何更改</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello，World]]></title>
        <id>https://xiaomanbaba.top/post/helloworld/</id>
        <link href="https://xiaomanbaba.top/post/helloworld/">
        </link>
        <updated>2020-02-25T04:11:48.000Z</updated>
        <content type="html"><![CDATA[<p>hello,world!!!</p>
]]></content>
    </entry>
</feed>